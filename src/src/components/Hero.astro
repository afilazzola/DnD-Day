---
interface Props {
  title: string;
  subtitle?: string;
  description?: string;
  showCta?: boolean;
  ctaText?: string;
  ctaHref?: string;
  backgroundImage?: string;
  backgroundVideo?: string;
}

const {
  title,
  subtitle,
  description,
  showCta = true,
  ctaText = 'Join the Fight',
  ctaHref = '/signup',
  backgroundImage,
  backgroundVideo
} = Astro.props;
---

<section class="relative min-h-[90vh] flex items-center justify-center overflow-hidden">
  <!-- Background Image (always present as fallback) -->
  {backgroundImage && (
    <div class="absolute inset-0">
      <img
        src={backgroundImage}
        alt=""
        class="hero-image w-full h-full object-cover"
      />
    </div>
  )}

  <!-- Background Video (progressive enhancement) -->
  {backgroundVideo && backgroundImage && (
    <div class="absolute inset-0 hero-video-container hidden">
      <video
        class="hero-video w-full h-full object-cover"
        poster={backgroundImage}
        muted
        loop
        playsinline
        preload="none"
        data-src={backgroundVideo}
      >
        <source data-src={backgroundVideo} type="video/mp4" />
      </video>
    </div>
  )}

  <!-- Dark Overlay for text readability -->
  <div class="absolute inset-0 bg-gradient-to-b from-dnd-bg/80 via-dnd-bg/70 to-dnd-bg"></div>

  <!-- Animated background elements -->
  <div class="absolute inset-0 overflow-hidden">
    <div class="absolute top-1/4 left-1/4 w-96 h-96 bg-dnd-secondary/5 rounded-full blur-3xl animate-pulse-slow"></div>
    <div class="absolute bottom-1/4 right-1/4 w-96 h-96 bg-dnd-primary/5 rounded-full blur-3xl animate-pulse-slow" style="animation-delay: 1.5s;"></div>
  </div>

  <!-- Content -->
  <div class="relative z-10 container-custom text-center px-4">
    {subtitle && (
      <p class="section-title animate-fade-in mb-4">{subtitle}</p>
    )}

    <h1 class="font-display text-4xl sm:text-5xl md:text-6xl lg:text-7xl font-bold mb-6 animate-slide-up">
      <span class="gold-gradient">{title}</span>
    </h1>

    {description && (
      <p class="text-lg md:text-xl text-dnd-text-muted max-w-2xl mx-auto mb-8 animate-fade-in" style="animation-delay: 0.3s;">
        {description}
      </p>
    )}

    {showCta && (
      <div class="flex flex-col sm:flex-row items-center justify-center gap-4 animate-fade-in" style="animation-delay: 0.5s;">
        <a href={ctaHref} class="btn btn-primary">
          {ctaText}
        </a>
        <a href="/story" class="btn btn-secondary">
          Learn the Story
        </a>
      </div>
    )}
  </div>

  <!-- Scroll indicator - positioned relative to section -->
  <div class="absolute bottom-8 left-1/2 -translate-x-1/2 animate-bounce z-10">
    <svg class="w-6 h-6 text-dnd-text-muted" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
    </svg>
  </div>
</section>

<style>
  /* Hide video for users who prefer reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .hero-video-container {
      display: none !important;
    }
    .hero-image {
      display: block !important;
    }
  }
</style>

<script>
  function initHeroVideo() {
    const videoContainer = document.querySelector('.hero-video-container');
    const video = document.querySelector('.hero-video') as HTMLVideoElement;
    const heroImage = document.querySelector('.hero-image') as HTMLImageElement;

    if (!videoContainer || !video) return;

    // Check if user prefers reduced motion
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      return;
    }

    // Check connection quality
    const connection = (navigator as any).connection ||
                       (navigator as any).mozConnection ||
                       (navigator as any).webkitConnection;

    if (connection) {
      // Skip video on slow connections or data saver mode
      const slowConnections = ['slow-2g', '2g', '3g'];
      if (slowConnections.includes(connection.effectiveType) || connection.saveData) {
        return;
      }
    }

    // Load and play the video
    const videoSrc = video.getAttribute('data-src');
    const source = video.querySelector('source');

    if (videoSrc && source) {
      video.src = videoSrc;
      source.src = videoSrc;
      video.load();

      // Show video container and hide image once video can play
      video.addEventListener('canplay', () => {
        videoContainer.classList.remove('hidden');
        if (heroImage) {
          heroImage.style.opacity = '0';
        }
        video.play().catch(() => {
          // If autoplay fails, hide video and show image
          videoContainer.classList.add('hidden');
          if (heroImage) {
            heroImage.style.opacity = '1';
          }
        });
      }, { once: true });

      // Fallback: if video doesn't load within 5 seconds, give up
      setTimeout(() => {
        if (video.readyState < 3) {
          videoContainer.classList.add('hidden');
          if (heroImage) {
            heroImage.style.opacity = '1';
          }
        }
      }, 5000);
    }
  }

  // Run on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHeroVideo);
  } else {
    initHeroVideo();
  }
</script>
